{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Определение границы отсечения при построении скора сайта\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Текущий подход использует условие total>1000 or positive > 5 для попадания в список оцениваемых урл-партов. Здесь total это общее количество уникальных посетителей урл-парта за период (обычно день), positives есть количество уникальных целевых посетителей за период. В контексте look-alike модели целевой посетитель есть пользователь, посетивший также целевую страницу в этот же период.\n",
    "Выбранный уровень определен экспертным образом. Попробуем оптимизировать эту границу.\n",
    "С одной стороны, необходимо убрать из ранжируемого списка мусор и шум, который будет мешать  правильной классификации. С другой, желательно не потерять релевантной информации на редкопосещаемых страницах. Пример: https://www.iglobe.ru/travelmiles/bankcards/raiffeisen/gold/bonus-and-miles. Страница не относится к банковской сфере, имеет менее 40 просмотров за день, при этом 3 посетителя относятся к целевым (= посетившие страницу кредитных карт райффайзенбанка). При текущем подходе страница будет отсеяна, но она является релевантной. \n",
    "При этом далеко не всегда удается определить релевантность страницы по урлу либо заголовку. Пример: otzovik.com\\review_3501522.html.\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    " Оценим вероятность того, что страницу посетит положительный пользователь в рамках \"случайного блуждания\", т.е. в предположении равномерной вероятности посещения всех доступных страниц .\n",
    " Есть N = 250 млн страниц , из которых положительные пользователи посетили k = 40 тысячу.\n",
    " Тогда вероятность того, что данную страницу посетил положительный пользователь, составляет k/N."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 101,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "N = 250000000\n",
    "k = 40000"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Оценим вероятность того, что найдется страница, которую посетили хотя бы 2 положительных пользователя. Это есть задача о днях рождения в чистом виде."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 104,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Appr1. Probability that urlpart with at least 2 positive exists: 95.92%.\n"
     ]
    }
   ],
   "source": [
    "def birth_coinc_prob(n,k):\n",
    "    return 1. - reduce(lambda x,y:x*y, [1-i*1./n for i in range(1,k)])\n",
    "print('Appr1. Probability that urlpart with at least 2 positive exists: {0:.2%}.'.format(birth_coinc_prob(N,k)))"
   ]
  },
  {
   "cell_type": "raw",
   "metadata": {},
   "source": [
    "Такие страницы скорее всего есть. Оценим вероятность, что найдутся страницы с хотя бы 3 посетителями. Для этого нужно сосчитать вероятность, что имеется ровно s страниц с парой положительных посетителей."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 105,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Appr1. Probability that there are exactly 2 urlparts with 2 positive visits and others has pos<2: 10.44%.\n"
     ]
    }
   ],
   "source": [
    "import scipy.special\n",
    "import scipy.misc\n",
    "def p(s,k,N):\n",
    "    '''Probability that there is s urlparts with pos=2 and the rest has pos<2.\n",
    "       Formula can be applied for relative small k,N'''\n",
    "    return (scipy.special.binom(N, s)* 1. / (2**s)) * scipy.special.binom(N-s, k-2*s) * scipy.misc.factorial(k) * 1. / (N**k)\n",
    "def p1(s,k,N):\n",
    "    '''Probability that there is s urlparts with pos=2 and the rest has pos<2.\n",
    "       Formula can be applied for relative big k,N'''\n",
    "    res = 1e10\n",
    "    for i in range(k-s): res *= (N-i)*1./N\n",
    "    for i in range(s):   res *= (k-i)*1./2/N\n",
    "    for i in range(s,2*s):   res *= (k-i)*1./s\n",
    "    return res/1e10\n",
    "s = 2\n",
    "print('Appr1. Probability that there are exactly {0} urlparts with 2 positive visits and others has pos<2: {1:.2%}.'.format(s,p1(s,k,N)))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 106,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Appr1. Probability that urlpart with at least 3 positive exists: 65.28%.\n"
     ]
    }
   ],
   "source": [
    "print('Appr1. Probability that urlpart with at least 3 positive exists: {0:.2%}.'.format(1 - sum([p1(s,k,N) for s in range(300)])))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Однако такой подход не учитывает, что у сайтов разная посещаемость.\n",
    "Применим другой подход. Пусть есть M = 180 млн всех пользователей, из них m = 1500 положительных. \n",
    "Есит страница с n = 50 уникальными посетителями. Страниц с хотя бы n посетителями N = 2.5 млн штук. При условии равновероятности посещения всеми пользователями, количество положительных визитов подчиняется биномиальному распределению с параметрами p = m/M и n.\n",
    "\n",
    "В этом случае вероятность, что найдется страница с несколькими положительными посетителями, оценивается сверху так:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 107,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Appr2.\n",
      "\n",
      "Case of 2500000 urlparts with at least 50 visits:\n",
      "Probability that there are urlparts with at least 2 positives is less than  19.15%.\n",
      "Probability that there are urlparts with at least 3 positives is less than  0.00%.\n",
      "Probability that there are urlparts with at least 2 positives is less than  0.00%.\n",
      "\n",
      "Case of 700000 urlparts with at least 200 visits:\n",
      "Probability that there are urlparts with at least 2 positives is less than  61.95%.\n",
      "Probability that there are urlparts with at least 3 positives is less than  0.05%.\n",
      "Probability that there are urlparts with at least 2 positives is less than  0.00%.\n",
      "\n",
      "Case of 310000 urlparts with at least 500 visits:\n",
      "Probability that there are urlparts with at least 2 positives is less than  93.13%.\n",
      "Probability that there are urlparts with at least 3 positives is less than  0.37%.\n",
      "Probability that there are urlparts with at least 2 positives is less than  0.00%.\n",
      "\n",
      "Case of 163000 urlparts with at least 1000 visits:\n",
      "Probability that there are urlparts with at least 2 positives is less than  99.64%.\n",
      "Probability that there are urlparts with at least 3 positives is less than  1.55%.\n",
      "Probability that there are urlparts with at least 2 positives is less than  0.00%.\n"
     ]
    }
   ],
   "source": [
    "M = 180000000\n",
    "m = 1500\n",
    "p= float(m)/M\n",
    "print('Appr2.')\n",
    "for (n,N) in [[50,2500000],[200,700000],[500,310000],[1000,163000]]:\n",
    "    print('\\nCase of {0} urlparts with at least {1} visits:'.format(N,n))\n",
    "    print('Probability that there are urlparts with at least 2 positives is less than  {0:.2%}.'.format(\n",
    "        1 - ((1-p)**n + n*p*(1-p)**(n-1))**N))\n",
    "    print('Probability that there are urlparts with at least 3 positives is less than  {0:.2%}.'.format(\n",
    "        1 - ((1-p)**n + n*p*(1-p)**(n-1) + n*(n-1)/2*(p**2)*(1-p)**(n-2))**N))\n",
    "    print('Probability that there are urlparts with at least 2 positives is less than  {0:.2%}.'.format(\n",
    "        1 - ((1-p)**n + n*p*(1-p)**(n-1) + n*(n-1)/2*(p**2)*(1-p)**(n-2) + n*(n-1)*(n-2)/6*(p**3)*(1-p)**(n-3))**N))\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Приведены сразу несколько вариантов агрегации по количеству визитов. Во всех случаях маловероятны ситуации случайного совпадения 3 и более положительных пользователей на сайте."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Итак, при всех подходах скорее всего есть страницы с 2 положительными посетителями в рамках случайной модели (т.е. для нерелевантной страницы). При этом 3 положительных посетителя и более, зашедших случайно, маловероятны.\n",
    "\n",
    "Но заметим, что не все страницы с 2 положительными посетителями, являются нерелевантными. Визуальный просмотр показал, что среди них есть достаточное количество полезных.\n",
    "Протестируем разную границу в рамках текущего подхода к скорингу пользователей."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 108,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "import datetime\n",
    "from pyspark import SparkConf, SparkContext, HiveContext\n",
    "sc.stop()\n",
    "conf = SparkConf().set(\"spark.executor.instances\", 32).set(\"spark.driver.maxResultSize\", \"32g\")\n",
    "sc = SparkContext(conf=conf)\n",
    "#sc.setCheckpointDir('/user/kposminin/checkpointdir/')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 109,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "import sklearn\n",
    "import sklearn.ensemble\n",
    "import numpy as np"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 110,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "def add_features(table):\n",
    "    si = 15 #score start index\n",
    "    def top_avg_score(slist): \n",
    "        return [sum(slist[:i])/i for i in [2,3,4,5,7,10]]\n",
    "    return [r + top_avg_score(r[si:si+11]) for r in table] \n",
    "\n",
    "def add_feature_rdd(row):\n",
    "    si = 15 #score start index\n",
    "    def top_avg_score(slist): \n",
    "        return [sum(slist[:i])/i for i in [2,3,4,5,7,10]]\n",
    "    r = row\n",
    "    return r + top_avg_score(r[si:si+11])\n",
    "    \n",
    "    \n",
    "# Load and parse the data file.\n",
    "# Load and parse the data file.\n",
    "train = sc.textFile(\"/user/kposminin/la_thres_20160817.txt\") \\\n",
    "  .map(lambda r:r.split('\\t')) \\\n",
    "  .filter(lambda r: (r[0] == '1') or (int(np.random.rand() * 500) == 0)) \\\n",
    "  .map(lambda r: [\n",
    "            int(r[0])\n",
    "            ,int(r[1])\n",
    "            ,[int(e) for e in r[2].replace('[','').replace(']','').split(',')]\n",
    "            ,[int(e) for e in r[3].replace('[','').replace(']','').split(',')]\n",
    "            ,[int(e) for e in r[4].replace('[','').replace(']','').split(',')]\n",
    "   ]) \\\n",
    "  .collect()\n",
    "\n",
    "test = sc.textFile(\"/user/kposminin/la_thres_20160824.txt\") \\\n",
    "  .map(lambda r:r.split('\\t')) \\\n",
    "  .filter(lambda r: (r[0] == '1') or (int(np.random.rand() * 500) == 0)) \\\n",
    "  .map(lambda r: [\n",
    "            int(r[0])\n",
    "            ,int(r[1])\n",
    "            ,[int(e) for e in r[2].replace('[','').replace(']','').split(',')]\n",
    "            ,[int(e) for e in r[3].replace('[','').replace(']','').split(',')]\n",
    "            ,[int(e) for e in r[4].replace('[','').replace(']','').split(',')]\n",
    "   ]) \\\n",
    "  .collect()\n",
    "\n",
    "test2 = sc.textFile(\"/user/kposminin/la_thres_20160818.txt\") \\\n",
    "  .map(lambda r:r.split('\\t')) \\\n",
    "  .filter(lambda r: (r[0] == '1') or (int(np.random.rand() * 500) == 0)) \\\n",
    "  .map(lambda r: [\n",
    "            int(r[0])\n",
    "            ,int(r[1])\n",
    "            ,[int(e) for e in r[2].replace('[','').replace(']','').split(',')]\n",
    "            ,[int(e) for e in r[3].replace('[','').replace(']','').split(',')]\n",
    "            ,[int(e) for e in r[4].replace('[','').replace(']','').split(',')]\n",
    "   ]) \\\n",
    "  .collect()\n",
    "\n",
    "test_rdd = sc.textFile(\"/user/kposminin/la_thres_20160818.txt\") \\\n",
    "  .map(lambda r:r.split('\\t')) \\\n",
    "  .map(lambda r: [\n",
    "            int(r[0])\n",
    "            ,int(r[1])\n",
    "            ,[int(e) for e in r[2].replace('[','').replace(']','').split(',')]\n",
    "            ,[int(e) for e in r[3].replace('[','').replace(']','').split(',')]\n",
    "            ,[int(e) for e in r[4].replace('[','').replace(']','').split(',')]\n",
    "   ]) \n",
    "#test_rdd = sc.textFile(\"/user/kposminin/la_20160824_2.txt\") \\\n",
    "#  .map(lambda r:r.split('\\t')) \\\n",
    "#  .map(lambda r:[int(e) for e in r]) \\\n",
    "#  .filter(lambda r: len(r) == 30) \\\n",
    "#  .map(add_feature_rdd) \n",
    "\n",
    "#test_rdd2 = sc.textFile(\"/user/kposminin/la_20160818_2.txt\") \\\n",
    "#  .map(lambda r:r.split('\\t')) \\\n",
    "#  .map(lambda r:[int(e) for e in r]) \\\n",
    "#  .filter(lambda r: len(r) == 30) \\\n",
    "#  .map(add_feature_rdd) \n",
    "    "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "данные в виде label, sc_param, scores_sorted_list,totals_list,positive_list. Так же берем семплированные данные для ускорения расчетов. Результативность на полных данных  очень близка к данным на семпле."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 114,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "\n",
    "def calc_aucroc(table, tott,post):\n",
    "    ''' calc threshold taking only scores with total > tott or positives > post'''\n",
    "    mv = -1250000\n",
    "    res = []\n",
    "    for r in table:\n",
    "        failed = True\n",
    "        for i in range(len(r[2])):\n",
    "            if (r[3][i] >= tott) or (r[4][i] >= post):\n",
    "                res.append([r[0],r[2][i]])\n",
    "                failed = False\n",
    "                break\n",
    "        if failed:\n",
    "            res.append([r[0],mv])\n",
    "    return sklearn.metrics.roc_auc_score(\n",
    "        y_true = [e[0] for e in res], \n",
    "        y_score = [e[1] for e in res]\n",
    "    )\n",
    "\n",
    "def calc_aucroc_and(table, tott1,tott2, post):\n",
    "    ''' calc threshold taking only scores with total > tott or positives > post'''\n",
    "    mv = -1250000\n",
    "    res = []\n",
    "    for r in table:\n",
    "        failed = True\n",
    "        for i in range(len(r[2])):\n",
    "            if (r[3][i] >= tott1) or (r[4][i] >= post) and (r[3][i] >= tott2):\n",
    "                res.append([r[0],r[2][i]])\n",
    "                failed = False\n",
    "                break\n",
    "        if failed:\n",
    "            res.append([r[0],mv])\n",
    "    return sklearn.metrics.roc_auc_score(\n",
    "        y_true = [e[0] for e in res], \n",
    "        y_score = [e[1] for e in res]\n",
    "    )"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 112,
   "metadata": {
    "collapsed": false,
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[5, 0, 0.72058446783371, 0.71936595206772291]\n",
      "[5, 1, 0.72170277186534615, 0.72040464930436987]\n",
      "[5, 2, 0.72029008895536861, 0.72036863204797497]\n",
      "[5, 3, 0.72029008895536861, 0.72036863204797497]\n",
      "[5, 5, 0.72029008895536861, 0.72036863204797497]\n",
      "[5, 6, 0.72029008895536861, 0.72036863204797497]\n",
      "[50, 0, 0.72058446783371, 0.71936595206772291]\n",
      "[50, 1, 0.73778351861056879, 0.72405656551810449]\n",
      "[50, 2, 0.73547644643397292, 0.72364501687468741]\n",
      "[50, 3, 0.73530971006766044, 0.72364501687468741]\n",
      "[50, 5, 0.73530971006766044, 0.72364501687468741]\n",
      "[50, 6, 0.73530971006766044, 0.72364501687468741]\n",
      "[100, 0, 0.72058446783371, 0.71936595206772291]\n",
      "[100, 1, 0.73682581635869204, 0.73400514709198861]\n",
      "[100, 2, 0.73385685197650685, 0.73370179966174209]\n",
      "[100, 3, 0.73382589869973236, 0.73362637314722545]\n",
      "[100, 5, 0.73382589869973236, 0.73362637314722545]\n",
      "[100, 6, 0.73382589869973236, 0.73362637314722545]\n",
      "[500, 0, 0.72058446783371, 0.71936595206772291]\n",
      "[500, 1, 0.76221135745481039, 0.75239722971941259]\n",
      "[500, 2, 0.76063935198185451, 0.75098829693849845]\n",
      "[500, 3, 0.76052459351508617, 0.75077745533542484]\n",
      "[500, 5, 0.76046382954006209, 0.75074704787973823]\n",
      "[500, 6, 0.76046382954006209, 0.75074704787973823]\n",
      "[1000, 0, 0.72058446783371, 0.71936595206772291]\n",
      "[1000, 1, 0.76235231748518972, 0.749717152768268]\n",
      "[1000, 2, 0.76211268225317164, 0.74862099620285183]\n",
      "[1000, 3, 0.76131868794555912, 0.74772569109843756]\n",
      "[1000, 5, 0.76125864367721408, 0.74767499065648568]\n",
      "[1000, 6, 0.76019694204335697, 0.74564126773448636]\n",
      "[5000, 0, 0.72058446783371, 0.71936595206772291]\n",
      "[5000, 1, 0.76671123217637582, 0.75430196866756893]\n",
      "[5000, 2, 0.76265750609870719, 0.75053823444504242]\n",
      "[5000, 3, 0.76104100131492181, 0.74800565368449523]\n",
      "[5000, 5, 0.7582165366007102, 0.74639169505763325]\n",
      "[5000, 6, 0.75672815138493577, 0.74262585731682007]\n",
      "[10000, 0, 0.72058446783371, 0.71936595206772291]\n",
      "[10000, 1, 0.76732551890663092, 0.75580188520749825]\n",
      "[10000, 2, 0.76066089842141449, 0.75144160450135933]\n",
      "[10000, 3, 0.75858587569776559, 0.74740304781238553]\n",
      "[10000, 5, 0.75481940681827353, 0.7444979094745493]\n",
      "[10000, 6, 0.74837596008753193, 0.73471959860119007]\n",
      "[30000, 0, 0.72058446783371, 0.71936595206772291]\n",
      "[30000, 1, 0.77263921697383375, 0.76170841008914592]\n",
      "[30000, 2, 0.765805447750327, 0.75624427833607299]\n",
      "[30000, 3, 0.76178392354039792, 0.75271173647114864]\n",
      "[30000, 5, 0.75607208632982215, 0.74793559459514691]\n",
      "[30000, 6, 0.75028589788310684, 0.73689104734228239]\n",
      "[50000, 0, 0.72058446783371, 0.71936595206772291]\n",
      "[50000, 1, 0.77149693999566782, 0.76074471740752636]\n",
      "[50000, 2, 0.76428342243137115, 0.7550460452492378]\n",
      "[50000, 3, 0.75907295574491362, 0.75068724265714248]\n",
      "[50000, 5, 0.75231086506613143, 0.7461231442152596]\n",
      "[50000, 6, 0.74519680837344859, 0.73215760500375238]\n"
     ]
    }
   ],
   "source": [
    "aucroc = []\n",
    "for tott in [5,50,100,500,1000, 5000, 10000,30000,50000]:\n",
    "    for post in [0,1,2,3,5,6]:\n",
    "        aucroc.append([tott,post,calc_aucroc(test, tott,post),calc_aucroc(test2, tott,post)])\n",
    "print('\\n'.join([str(r) for r in aucroc]))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Согласно моделированию, наилучшие результаты получаются в случае использования условия total > 30000 or positive > 0, при усилении условия на positive>1 показатель aucroc немного падает."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": true
   },
   "source": [
    "Немного изменим условие, чтобы отсеять страницы с малым количеством посещений."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 115,
   "metadata": {
    "collapsed": false,
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[500, 5, 0, 0.72029008895536861, 0.72036863204797497]\n",
      "[500, 5, 1, 0.76119014079403846, 0.75237808456342448]\n",
      "[500, 5, 2, 0.76063935198185451, 0.75098829693849845]\n",
      "[500, 5, 3, 0.76052459351508617, 0.75077745533542484]\n",
      "[500, 20, 0, 0.71943716233211941, 0.72024598625729186]\n",
      "[500, 20, 1, 0.76080435327789198, 0.75243310506681271]\n",
      "[500, 20, 2, 0.76063935198185451, 0.75098829693849845]\n",
      "[500, 20, 3, 0.76052459351508617, 0.75077745533542484]\n",
      "[500, 50, 0, 0.73530971006766044, 0.72364501687468741]\n",
      "[500, 50, 1, 0.76066507059990351, 0.75248219176488496]\n",
      "[500, 50, 2, 0.76062626769087316, 0.75098829693849845]\n",
      "[500, 50, 3, 0.76052459351508617, 0.75077745533542484]\n",
      "[500, 100, 0, 0.73382589869973236, 0.73362637314722545]\n",
      "[500, 100, 1, 0.76024233774826633, 0.75239753111904772]\n",
      "[500, 100, 2, 0.76062872128991121, 0.75096073770936367]\n",
      "[500, 100, 3, 0.76052459351508617, 0.75077745533542484]\n",
      "[500, 1000, 0, 0.76046382954006209, 0.75074704787973823]\n",
      "[500, 1000, 1, 0.76046382954006209, 0.75074704787973823]\n",
      "[500, 1000, 2, 0.76046382954006209, 0.75074704787973823]\n",
      "[500, 1000, 3, 0.76046382954006209, 0.75074704787973823]\n",
      "[5000, 5, 0, 0.72029008895536861, 0.72036863204797497]\n",
      "[5000, 5, 1, 0.76593017256441198, 0.75428170958876273]\n",
      "[5000, 5, 2, 0.76265750609870719, 0.75053823444504242]\n",
      "[5000, 5, 3, 0.76104100131492181, 0.74800565368449523]\n",
      "[5000, 20, 0, 0.71943716233211941, 0.72024598625729186]\n",
      "[5000, 20, 1, 0.76562505698168681, 0.75433526202476164]\n",
      "[5000, 20, 2, 0.76265750609870719, 0.75053823444504242]\n",
      "[5000, 20, 3, 0.76104100131492181, 0.74800565368449523]\n",
      "[5000, 50, 0, 0.73530971006766044, 0.72364501687468741]\n",
      "[5000, 50, 1, 0.7655012014696132, 0.75438163361445432]\n",
      "[5000, 50, 2, 0.76264533822637759, 0.75053823444504242]\n",
      "[5000, 50, 3, 0.76104100131492181, 0.74800565368449523]\n",
      "[5000, 100, 0, 0.73382589869973236, 0.73362637314722545]\n",
      "[5000, 100, 1, 0.76512367939007242, 0.75431591091235606]\n",
      "[5000, 100, 2, 0.76264748674517024, 0.75053399601267379]\n",
      "[5000, 100, 3, 0.76104100131492181, 0.74800565368449523]\n",
      "[5000, 1000, 0, 0.76019692790836491, 0.74564126899031824]\n",
      "[5000, 1000, 1, 0.76495170836503457, 0.75081947923538117]\n",
      "[5000, 1000, 2, 0.76109659070493674, 0.74690301577109253]\n",
      "[5000, 1000, 3, 0.75945521069096167, 0.7454446861016486]\n",
      "[10000, 5, 0, 0.72029008895536861, 0.72036863204797497]\n",
      "[10000, 5, 1, 0.76654445929466708, 0.75578162612869204]\n",
      "[10000, 5, 2, 0.76066089842141449, 0.75144160450135933]\n",
      "[10000, 5, 3, 0.75858587569776559, 0.74740304781238553]\n",
      "[10000, 20, 0, 0.71943716233211941, 0.72024598625729186]\n",
      "[10000, 20, 1, 0.76623928952780573, 0.75583516851803645]\n",
      "[10000, 20, 2, 0.76066089842141449, 0.75144160450135933]\n",
      "[10000, 20, 3, 0.75858587569776559, 0.74740304781238553]\n",
      "[10000, 50, 0, 0.73530971006766044, 0.72364501687468741]\n",
      "[10000, 50, 1, 0.76611541281324402, 0.75588153006107461]\n",
      "[10000, 50, 2, 0.76064873054908477, 0.75144160450135933]\n",
      "[10000, 50, 3, 0.75858587569776559, 0.74740304781238553]\n",
      "[10000, 100, 0, 0.73382589869973236, 0.73362637314722545]\n",
      "[10000, 100, 1, 0.76573784832872716, 0.75581616903853865]\n",
      "[10000, 100, 2, 0.76065082841748943, 0.75143736606899059]\n",
      "[10000, 100, 3, 0.75858587569776559, 0.74740304781238553]\n",
      "[10000, 1000, 0, 0.76019692790836491, 0.74564126899031824]\n",
      "[10000, 1000, 1, 0.76556546149933946, 0.75237183680015507]\n",
      "[10000, 1000, 2, 0.75892303177373766, 0.74789194313716123]\n",
      "[10000, 1000, 3, 0.75698764745871072, 0.74490725287730286]\n",
      "[30000, 5, 0, 0.72029008895536861, 0.72036863204797497]\n",
      "[30000, 5, 1, 0.77185815736186991, 0.7616881510103396]\n",
      "[30000, 5, 2, 0.765805447750327, 0.75624427833607299]\n",
      "[30000, 5, 3, 0.76178392354039792, 0.75271173647114864]\n",
      "[30000, 20, 0, 0.71943716233211941, 0.72024598625729186]\n",
      "[30000, 20, 1, 0.77155298759500857, 0.76174168460886116]\n",
      "[30000, 20, 2, 0.765805447750327, 0.75624427833607299]\n",
      "[30000, 20, 3, 0.76178392354039792, 0.75271173647114864]\n",
      "[30000, 50, 0, 0.73530971006766044, 0.72364501687468741]\n",
      "[30000, 50, 1, 0.77142908732212667, 0.76178803736107681]\n",
      "[30000, 50, 2, 0.76579327987799728, 0.75624427833607299]\n",
      "[30000, 50, 3, 0.76178392354039792, 0.75271173647114864]\n",
      "[30000, 100, 0, 0.73382589869973236, 0.73362637314722545]\n",
      "[30000, 100, 1, 0.77105147572096966, 0.76172264494274544]\n",
      "[30000, 100, 2, 0.76579533298559355, 0.75624003990370425]\n",
      "[30000, 100, 3, 0.76178392354039792, 0.75271173647114864]\n",
      "[30000, 1000, 0, 0.76019692790836491, 0.74564126899031824]\n",
      "[30000, 1000, 1, 0.77088327049339922, 0.75839195418094629]\n",
      "[30000, 1000, 2, 0.76415832186208055, 0.75208288748164398]\n",
      "[30000, 1000, 3, 0.7603640070482347, 0.74950946581470834]\n",
      "[50000, 5, 0, 0.72029008895536861, 0.72036863204797497]\n",
      "[50000, 5, 1, 0.77071588038370398, 0.76072445832872004]\n",
      "[50000, 5, 2, 0.76428342243137115, 0.7550460452492378]\n",
      "[50000, 5, 3, 0.75907295574491362, 0.75068724265714248]\n",
      "[50000, 20, 0, 0.71943716233211941, 0.72024598625729186]\n",
      "[50000, 20, 1, 0.77041071061684252, 0.76077799318307382]\n",
      "[50000, 20, 2, 0.76428342243137115, 0.7550460452492378]\n",
      "[50000, 20, 3, 0.75907295574491362, 0.75068724265714248]\n",
      "[50000, 50, 0, 0.73530971006766044, 0.72364501687468741]\n",
      "[50000, 50, 1, 0.77028681269979282, 0.76082434719112091]\n",
      "[50000, 50, 2, 0.76427125455904155, 0.7550460452492378]\n",
      "[50000, 50, 3, 0.75907295574491362, 0.75068724265714248]\n",
      "[50000, 100, 0, 0.73382589869973236, 0.73362637314722545]\n",
      "[50000, 100, 1, 0.76990920581029976, 0.76075874253721321]\n",
      "[50000, 100, 2, 0.76427330766663781, 0.75504180681686894]\n",
      "[50000, 100, 3, 0.75907295574491362, 0.75068724265714248]\n",
      "[50000, 1000, 0, 0.76019692790836491, 0.74564126899031824]\n",
      "[50000, 1000, 1, 0.76973982148880848, 0.75740887271196677]\n",
      "[50000, 1000, 2, 0.76263799392008758, 0.75066391809288091]\n",
      "[50000, 1000, 3, 0.75767894398152824, 0.74731650718632425]\n",
      "[100000, 5, 0, 0.72029008895536861, 0.72036863204797497]\n",
      "[100000, 5, 1, 0.7691561063905421, 0.75941925976721814]\n",
      "[100000, 5, 2, 0.76285104005412907, 0.75326669859593953]\n",
      "[100000, 5, 3, 0.75745969729763729, 0.74786005756743068]\n",
      "[100000, 20, 0, 0.71943716233211941, 0.72024598625729186]\n",
      "[100000, 20, 1, 0.76885093662368054, 0.75947279964489911]\n",
      "[100000, 20, 2, 0.76285104005412907, 0.75326669859593953]\n",
      "[100000, 20, 3, 0.75745969729763729, 0.74786005756743068]\n",
      "[100000, 50, 0, 0.73530971006766044, 0.72364501687468741]\n",
      "[100000, 50, 1, 0.76872704106246292, 0.75951915867627362]\n",
      "[100000, 50, 2, 0.76283887218179935, 0.75326669859593953]\n",
      "[100000, 50, 3, 0.75745969729763729, 0.74786005756743068]\n",
      "[100000, 100, 0, 0.73382589869973236, 0.73362637314722545]\n",
      "[100000, 100, 1, 0.7683494388846337, 0.75945357411567471]\n",
      "[100000, 100, 2, 0.76284092528939595, 0.75326246016357068]\n",
      "[100000, 100, 3, 0.75745969729763729, 0.74786005756743068]\n",
      "[100000, 1000, 0, 0.76019692790836491, 0.74564126899031824]\n",
      "[100000, 1000, 1, 0.76817999095567824, 0.75607588887160371]\n",
      "[100000, 1000, 2, 0.76120561154284549, 0.74885841246291918]\n",
      "[100000, 1000, 3, 0.75606845128103117, 0.74447948139852616]\n"
     ]
    }
   ],
   "source": [
    "aucroc1 = []\n",
    "for tott1 in [500, 5000, 10000,30000,50000,100000]:\n",
    "    for tott2 in [5,20,50,100,1000]:\n",
    "        for post in [0,1,2,3]:\n",
    "            aucroc1.append([tott1,tott2, post,calc_aucroc_and(test, tott1,tott2, post),calc_aucroc_and(test2, tott1,tott2, post)])\n",
    "print('\\n'.join([str(r) for r in aucroc1]))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Итак, изменение границы позволяет варьировать aucroc и добиваться улучшения результативности по стравнению с границей текущего подхода.\n",
    "Выбрана граница в виде total > 30000 or (positive >= 1 and total > 20)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 100,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": 123,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "AUC ROC on full test data 20160824. Old threshold: 0.74517694754\n",
      "AUC ROC on full test data 20160824. New threshold: 0.761356171395\n"
     ]
    }
   ],
   "source": [
    "curtot1, curtot2, curpos = 1000,0,6\n",
    "newtot1, newtot2, newpos = 30000, 20, 1\n",
    "               \n",
    "def find_score(r, tott1,tott2, post):\n",
    "    mv = -1250000\n",
    "    for i in range(len(r[2])):\n",
    "        if (r[3][i] >= tott1) or (r[4][i] >= post) and (r[3][i] >= tott2):\n",
    "            return r[2][i]\n",
    "            break\n",
    "    return mv        \n",
    "                \n",
    "res = test_rdd.map(lambda r: (r[0], find_score(r,curtot1, curtot2, curpos), find_score(r, newtot1, newtot2, newpos)))\n",
    "\n",
    "from pyspark.mllib.evaluation import BinaryClassificationMetrics\n",
    "\n",
    "print('AUC ROC on full test data 20160818. Old threshold: {0}'.format(\n",
    "        BinaryClassificationMetrics(res.map(lambda r: (float(r[1]),float(r[0])))).areaUnderROC)\n",
    ")\n",
    "\n",
    "print('AUC ROC on full test data 20160818. New threshold: {0}'.format(\n",
    "        BinaryClassificationMetrics(res.map(lambda r: (float(r[2]),float(r[0])))).areaUnderROC)\n",
    ")\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Вывод. Новый порог в виде total > 30000 or (positive >= 1 and total > 20) позволяет добиться небольшого улучшения AUCROC. Рекомендуется к использованию в модели look alike."
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 2",
   "language": "python",
   "name": "python2"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 2
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython2",
   "version": "2.7.10"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 0
}
