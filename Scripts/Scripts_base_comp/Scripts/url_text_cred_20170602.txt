create table user_kposminin.cred_scoring_phones as 
with ph_ymd as 
 (select distinct phone_num, call_ymd from user_kposminin.cred_scoring_weblog)
select
  a.phone_num, 
  a.call_ymd,
  max(b.approve) as approve
from
  ph_ymd a
  left join user_kposminin.ccall_aza_id b on substr(a.phone_num,3,20) = substr(b.phone_mobile,2,20)  and a.call_ymd = b.call_ymd
group by
  a.phone_num, 
  a.call_ymd  
  ;


-- array UDF

-- /user/kposminin/brickhouse-0.6.0.jar
-- Add the UDF jar file
add jar hdfs:///user/kposminin/brickhouse-0.6.0.jar;

-- Drop existing functions if exist, so that no conflicts
drop function if exists combine_unique;
drop function if exists array_intersect;
drop function if exists combine;

-- If you want the functions loaded temporary in this session only
CREATE TEMPORARY FUNCTION combine AS 'brickhouse.udf.collect.CombineUDF';
CREATE TEMPORARY FUNCTION combine_unique AS 'brickhouse.udf.collect.CombineUniqueUDAF';
CREATE TEMPORARY FUNCTION array_intersect AS "brickhouse.udf.collect.ArrayIntersectUDF";

-- Or you can make it permanently
CREATE FUNCTION combine AS 'brickhouse.udf.collect.CombineUDF';
CREATE FUNCTION combine_unique AS 'brickhouse.udf.collect.CombineUniqueUDAF';
CREATE FUNCTION array_intersect AS "brickhouse.udf.collect.ArrayIntersectUDF";


-- This is my test query
set hive.cli.print.header=true;
select combine(array('a','b','c'), array('b','c','d')) as combine
, combine_unique(combine(array('a','b','c'), array('b','c','d'))) as union
, array_intersect(array('a','b','c'), array('b','c','d')) as intersect
, size(array_intersect(array('a','b','c'), array('b','c','d')))/size(combine_unique(combine(array('a','b','c'), array('b','c','d')))) as jaccard_similarity
;






set hive.support.quoted.identifiers=none;

insert overwrite table prod_features_liveinternet.id_feat_accum partition (first_calc_ymd, last_calc_ymd)
select 
  a.`(last_calc_ymd)?+.+`,
  '2017-05-31' as last_calc_ymd  
from user_kposminin.id_feat_accum a
where first_calc_ymd = '2017-05-16' and last_calc_ymd  = '2017-05-26'
limit 1000;

set hive.support.quoted.identifiers=column;




add jar hdfs:///user/kposminin/brickhouse-0.6.0.jar;

drop function if exists combine_unique;
drop function if exists array_intersect;
drop function if exists combine;

CREATE FUNCTION combine AS 'brickhouse.udf.collect.CombineUDF';
CREATE FUNCTION combine_unique AS 'brickhouse.udf.collect.CombineUniqueUDAF';
CREATE FUNCTION array_intersect AS "brickhouse.udf.collect.ArrayIntersectUDF";

-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 

create table user_kposminin.cred_scor_title_bow as
select
  w.phone_num, 
  w.call_ymd,
  max(p.approve) as approve,
  combine(combine(t.init_url, t.url_bow))
from 
  user_kposminin.cred_scoring_weblog w
  inner join user_kposminin.cred_scoring_phones p on a.phone_num = b.phone_num and a.call_ymd = b.call_ymd
  inner join user_kposminin.cred_scor_url_titles2 t on t.init_url = w.url
group by
  w.phone_num, 
  w.call_ymd
;






m -- /user/kposminin/brickhouse-0.6.0.jar
-- Add the UDF jar file
add jar hdfs:///user/kposminin/brickhouse-0.6.0.jar;

-- Drop existing functions if exist, so that no conflicts
drop function if exists combine_unique;
drop function if exists array_intersect;
drop function if exists combine;

-- If you want the functions loaded temporary in this session only
CREATE TEMPORARY FUNCTION combine AS 'brickhouse.udf.collect.CombineUDF';
CREATE TEMPORARY FUNCTION combine_unique AS 'brickhouse.udf.collect.CombineUniqueUDAF';
CREATE TEMPORARY FUNCTION array_intersect AS "brickhouse.udf.collect.ArrayIntersectUDF";

-- Or you can make it permanently
CREATE FUNCTION combine AS 'brickhouse.udf.collect.CombineUDF';
CREATE FUNCTION combine_unique AS 'brickhouse.udf.collect.CombineUniqueUDAF';
CREATE FUNCTION array_intersect AS "brickhouse.udf.collect.ArrayIntersectUDF";


-- This is my test query
set hive.cli.print.header=true;
select combine(array('a','b','c'), array('b','c','d')) as combine
, combine_unique(combine(array('a','b','c'), array('b','c','d'))) as union
, array_intersect(array('a','b','c'), array('b','c','d')) as intersect
, size(array_intersect(array('a','b','c'), array('b','c','d')))/size(combine_unique(combine(array('a','b','c'), array('b','c','d')))) as jaccard_similarity
;







-- reso.ru/Retail/Motor
create table user_kposminin.la_url_texts_id_train as
select distinct 
  uid as id,
  load_src, 
  ymd
from 
  prod_odd.weblog
where
  url like '%reso.ru/Retail/Motor%'
  and ymd between '2017-03-25' and date_add('2017-03-25',7)
  ;
  
create table user_kposminin.la_url_texts_urls_train as 
select 
  w.url,
  count(distinct w.uid) as cnt,
  count(distinct p.id) as pos_cnt  
from 
  prod_odd.weblog w
  left join user_kposminin.la_url_texts_id_train p on p.id = w.uid and p.load_src = w.load_src
where
  w.ymd between date_add('2017-03-25',-3) and ate_add('2017-03-25',7-3)
  and w.ymd between date_add(p.ymd,-3) and p.ymd
group by w.url
having cnt > 100
  ;


create table user_kposminin.la_url_texts_id_test as
select distinct 
  uid as id,
  load_src, 
  ymd
from 
  prod_odd.weblog
where
  url like '%reso.ru/Retail/Motor%'
  and ymd between '2017-04-25' and date_add('2017-04-25',7)
  ;
  
create table user_kposminin.la_url_texts_urls_test as 
select 
  w.url,
  count(distinct w.uid) as cnt,
  count(distinct p.id) as pos_cnt  
from 
  prod_odd.weblog w
  left join user_kposminin.la_url_texts_id_test p on p.id = w.uid and p.load_src = w.load_src
where
  w.ymd between date_add('2017-04-25',-3) and ate_add('2017-04-25',7-3)
  and w.ymd between date_add(p.ymd,-3) and p.ymd
group by w.url
having cnt > 100
  ;





create table user_kposminin.cred_scor_url_titles7 as
select 
  init_url,
  split(regexp_replace(title_bow,'(u\')|(\')|"|\\[|\\]| ',''),',') as title_bow
from user_kposminin.cred_scor_url_titles5
;



drop table user_kposminin.cred_scor_url_titles6;
  create table user_kposminin.cred_scor_url_titles6 as 
  select a.init_url as url,a.url_bow,b.title_bow from 
   user_kposminin.cred_scor_url_titles4 a
   inner join user_kposminin.cred_scor_url_titles7 b on a.init_url = b.init_url
;

create temporary function trunc as 'brickhouse.udf.collect.TruncateArrayUDF';
create table user_kposminin.cred_scor_url_titles9 as 
select url, trunc(bow,least(size(bow),100)) as bow
from user_kposminin.cred_scor_url_titles8
;


-- cred_scor

drop table user_kposminin.cred_scor_title_bow;
create table user_kposminin.cred_scor_title_bow as 
with id_to_take as 
 (
 select   
  w.phone_num, 
  w.call_ymd,
  count(url) as url_cnt
 from
  user_kposminin.cred_scoring_weblog w
 group by
  w.phone_num, 
  w.call_ymd
 having
  url_cnt < 20000
 ),

tmp2 as
 (
select
  w.phone_num, 
  w.call_ymd,
  p.approve as approve,
  t.bow
from 
  user_kposminin.cred_scoring_weblog w
  left semi join id_to_take t1 on t1.call_ymd = w.call_ymd and t1.phone_num = w.phone_num
  inner join user_kposminin.cred_scoring_phones p on p.phone_num = w.phone_num and p.call_ymd = w.call_ymd
  inner join user_kposminin.cred_scor_url_titles9 t on t.url = regexp_extract(w.url,'(http)?s?(://)?(www\.)?(.*)',4)
 )
 
select 
  phone_num,
  call_ymd,
  max(approve) as approve,
  collect_list(words)
from tmp2 LATERAL VIEW explode(bow) a as words
group by
  phone_num, 
  call_ymd
;

только так работает:
разбить на 16 частей

insert into table user_kposminin.cred_scor_title_bow1
select 
  phone_num,
  call_ymd,
  max(approve) as approve,
  collect_list(words) as bow,
  max(cnt) as cnt
from user_kposminin.cred_scor_title_bow_tmp_4 LATERAL VIEW explode(bow) a as words
where
  substr(md5(phone_num),1,1) = 'f'
group by
  phone_num, 
  call_ymd
; 

